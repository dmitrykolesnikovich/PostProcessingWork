#version 450
#define USE_ALPHA_TEST 1
#define NUM_GBUFFER_RTS 5










#ifndef GL_ES


#endif

#define float2 vec2
#define bool4 bvec4

#define float3 vec3
#define float4 vec4
#define bool2 bvec2
#define bool3 bvec3
#define float2x2 mat2
#define float3x3 mat3
#define float4x4 mat4
#define matrix   mat4
#define float4x3 mat4x3

#define half2 vec2
#define half3 vec3
#define half4 vec4

#define uint2 uvec2
#define uint3 uvec3
#define uint4 uvec4

#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

#define lerp(x,y,v) mix(x,y,v)
#define rcp(x) 1.0/x
#define saturate(x) clamp(x, 0.0, 1.0)
#define frac(x) fract(x)
#define rsqrt(x) inversesqrt(x)
#define InterlockedOr(x, y) atomicOr(x, y)
#define firstbithigh(x) findMSB(x)
#define firstbitlow(x)  findLSB(x)
#define atan2(y,x)  atan(y,x)
#define reversebits(x) bitfieldReverse(x)
#define countbits(x)   bitCount(x)
#define asuint(x) floatBitsToUint(x)
#define ddx(x)    dFdx(x)
#define ddy(x)    dFdy(x)



#define isfinite(x) !(isnan(x) || isinf(x))

#ifndef GroupMemoryBarrierWithGroupSync
#define GroupMemoryBarrierWithGroupSync barrier
#endif
#define groupshared shared

#define GroupMemoryBarrier memoryBarrier

vec4 mul(in vec4 v, in mat4 m )
{
	return m * v;
}

vec3 mul(in vec3 v, in mat3 m )
{
	return m * v;
}

vec4 mul(in mat4 m , in vec4 v)
{
	return m * v;
}

vec3 mul(in mat3 m , in vec3 v)
{
	return m * v;
}

vec2 mul(in mat2 m , in vec2 v)
{
	return m * v;
}

void sincos(float angle, out float _sin, out float _cos)
{
    _sin = sin(angle);
    _cos = cos(angle);
}

void sincos(float2 angle, out float2 _sin, out float2 _cos)
{
    _sin = sin(angle);
    _cos = cos(angle);
}

float asfloat(uint i)
{
    return uintBitsToFloat(i);
}

float asfloat(int i)
{
    return intBitsToFloat(i);
}

float f16tof32( in uint value)
{
    return unpackHalf2x16(value).x;
}

float2 f16tof32( in uint2 value)
{
    return float2(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x);
}

float3 f16tof32( in uint3 value)
{
    return float3(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x, unpackHalf2x16(value.z).x);
}

float4 f16tof32( in uint4 value)
{
    return float4(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x, unpackHalf2x16(value.z).x, unpackHalf2x16(value.w).x);
}

uint f32tof16(in float value)
{
    return packHalf2x16(vec2(value, 0));
}

uint2 f32tof16(in vec2 value)
{
    return uint2(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)));
}

uint3 f32tof16(in float3 value)
{
    return uint3(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)), packHalf2x16(vec2(value.z, 0)));
}


uint4 f32tof16(in float4 value)
{
    return uint4(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)), packHalf2x16(vec2(value.z, 0)), packHalf2x16(vec2(value.w, 0)));
}

#define SV_ThreadGroupSize gl_WorkGroupSize
#define SV_NumThreadGroup  gl_NumWorkGroups
#define SV_GroupID         gl_WorkGroupID
#define SV_GroupThreadID   gl_LocalInvocationID
#define SV_DispatchThreadID gl_GlobalInvocationID
#define SV_GroupIndex      gl_LocalInvocationIndex





const float4 kRadarColors[14] = float4[14]
(
    float4(0,0.9255,0.9255,1),   
    float4(0,0.62745,0.9647,1),  
    float4(0,0,0.9647,1),        
    float4(0,1,0,1),             
    float4(0,0.7843,0,1),        
    float4(0,0.5647,0,1),        
    float4(1,1,0,1),             
    float4(0.90588,0.75294,0,1), 
    float4(1,0.5647,0,1),        
    float4(1,0,0,1),             
    float4(0.8392,0,0,1),        
    float4(0.75294,0,0,1),       
    float4(1,0,1,1),             
    float4(0.6,0.3333,0.7882,1)  
);





#define TILE_RES 16
#define MAX_NUM_LIGHTS_PER_TILE 272
#define MAX_NUM_VPLS_PER_TILE 1024





#define MAX_NUM_SHADOWCASTING_POINTS     12
#define MAX_NUM_SHADOWCASTING_SPOTS      12






uniform mat4 g_mWorld;
uniform mat4 g_mViewProjection;
uniform float2 g_CameraRange;   

layout(binding = 0) uniform cbPerFrame 
{
    matrix              g_mView                      ;
    matrix              g_mProjection                ;
    matrix              g_mProjectionInv             ;
    matrix              g_mViewProjectionInvViewport ;
    float4              g_AmbientColorUp             ;
    float4              g_AmbientColorDown           ;
    float3              g_vCameraPos                 ;
    float               g_fAlphaTest                 ;
    uint                g_uNumLights                 ;
    uint                g_uNumSpotLights             ;
    uint                g_uWindowWidth               ;
    uint                g_uWindowHeight              ;
    uint                g_uMaxNumLightsPerTile       ;
    uint                g_uMaxNumElementsPerTile     ;
    uint                g_uNumTilesX                 ;
    uint                g_uNumTilesY                 ;
    uint                g_uMaxVPLs                   ;
    uint                g_uMaxNumVPLsPerTile         ;
    uint                g_uMaxNumVPLElementsPerTile  ;
    float               g_fVPLSpotStrength           ;
    float               g_fVPLSpotRadius             ;
    float               g_fVPLPointStrength          ;
    float               g_fVPLPointRadius            ;
    float               g_fVPLRemoveBackFaceContrib  ;
    float               g_fVPLColorThreshold         ;
    float               g_fVPLBrightnessThreshold    ;
    float               g_fPerFramePad1              ;
    float               g_fPerFramePad2              ;
};

layout(binding = 1) uniform cbShadowConstants 
{
    matrix              g_mPointShadowViewProj[ MAX_NUM_SHADOWCASTING_POINTS ][ 6 ];
    matrix              g_mSpotShadowViewProj[ MAX_NUM_SHADOWCASTING_SPOTS ];
    float4              g_ShadowBias;  
};

layout(binding = 2) uniform cbVPLConstants 
{
    uint                g_uNumVPLs;
    uint                g_uVPLPad[ 3 ];
};

struct VPLData
{
    float4 Direction;
    float4 Color;
    float4 SourceLightDirection;
};













float4 ConvertProjToView( float4 p )
{
    p = mul( p, g_mProjectionInv );
    p /= p.w;
    return p;
}


float ConvertProjDepthToView( float z )
{
    float mZFar =g_CameraRange.y;
    float mZNear = g_CameraRange.x;
    float fCamSpaceZ = mZFar*mZNear/(mZFar-z*(mZFar-mZNear));

    return fCamSpaceZ;
}

uint GetTileIndex(float2 ScreenPos)
{
    float fTileRes = float(TILE_RES);
    uint nTileIdx = uint(floor(ScreenPos.x/fTileRes)+floor(ScreenPos.y/fTileRes)*g_uNumTilesX);
    return nTileIdx;
}



void GetLightListInfo(usamplerBuffer PerTileLightIndexBuffer, in uint uMaxNumLightsPerTile, in uint uMaxNumElementsPerTile, in float4 SVPosition, out uint uFirstLightIndex, out uint uNumLights)
{
    uint nTileIndex = GetTileIndex(SVPosition.xy);
    int nStartIndex = int(uMaxNumElementsPerTile*nTileIndex);

    
    uint uHalfZBitsHigh = texelFetch(PerTileLightIndexBuffer, nStartIndex).x;
    uint uHalfZBitsLow = texelFetch(PerTileLightIndexBuffer, nStartIndex+1).x;
    uint uHalfZBits = (uHalfZBitsHigh << 16) | uHalfZBitsLow;
    float fHalfZ = asfloat(uHalfZBits);

    float fViewPosZ = ConvertProjDepthToView( SVPosition.z );

    uFirstLightIndex = (fViewPosZ < fHalfZ) ? (nStartIndex + 4) : (nStartIndex + 4 + uMaxNumLightsPerTile);
    uNumLights = (fViewPosZ < fHalfZ) ? texelFetch(PerTileLightIndexBuffer, nStartIndex+2).x : texelFetch(PerTileLightIndexBuffer, nStartIndex+3).x;
}

float4 ConvertNumberOfLightsToGrayscale(uint nNumLightsInThisTile, uint uMaxNumLightsPerTile)
{
    float fPercentOfMax = float(nNumLightsInThisTile) / float(uMaxNumLightsPerTile);
    return float4(fPercentOfMax, fPercentOfMax, fPercentOfMax, 1.0f);
}

float4 ConvertNumberOfLightsToRadarColor(uint nNumLightsInThisTile, uint uMaxNumLightsPerTile)
{
    
    if( nNumLightsInThisTile == 0 ) return float4(0,0,0,1);
    
    else if( nNumLightsInThisTile == uMaxNumLightsPerTile ) return float4(0.847,0.745,0.921,1);
    
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return float4(1,1,1,1);
    
    else
    {
        

        
        
        float fLogBase = exp2(0.07142857f*log2(float(uMaxNumLightsPerTile)));

        
        
        int nColorIndex = int(floor(log2(float(nNumLightsInThisTile)) / log2(fLogBase)));
        return kRadarColors[nColorIndex];
    }
}

































layout(binding = 13) uniform sampler2DShadow      g_PointShadowAtlas;
layout(binding = 14) uniform sampler2DShadow      g_SpotShadowAtlas;





int Vector3ToFace( float3 vec )
{
    int face = 0;
    float x = vec.x;
    float y = vec.y;
    float z = vec.z;
    if((abs(x) > abs(y)) && (abs(x) > abs(z)))
    {
        if (x>=0)
        {
            face = 0;
        }
        else
        {
            face = 1;
        }
    }
    else if((abs(y) > abs(x)) && (abs(y) > abs(z)))
    {
        if (y>=0)
        {
            face = 2;
        }
        else
        {
            face = 3;
        }
    }
    else
    {
        if (z>=0)
        {
            face = 4;
        }
        else
        {
            face = 5;
        }
    }

    return face;
}

float FilterShadow( sampler2DShadow atlas, float3 uv )
{
    float shadow = 0.0;

    const int kernelLevel = 2;
    const int kernelWidth = 2*kernelLevel + 1;
    for ( int i = -kernelLevel; i <= kernelLevel; i++ )
    {
        for ( int j = -kernelLevel; j <= kernelLevel; j++ )
        {
            shadow += textureOffset(atlas , uv, int2( i, j ) ).r;
        }
    }

    shadow /= (kernelWidth*kernelWidth);

    return shadow;
}

float DoShadow( uint nShadowIndex, in float3 vPosition, float3 vLightDir, float fDistanceTerm )
{
    float3 uv = -vLightDir;
    uv.z = -uv.z;

    int face = Vector3ToFace( uv.xyz );

    float4 shadowTexCoord = mul( float4( vPosition, 1 ), g_mPointShadowViewProj[ nShadowIndex ][ face ] );
    shadowTexCoord.xyz = shadowTexCoord.xyz / shadowTexCoord.w;

    shadowTexCoord.x = shadowTexCoord.x/2 + 0.5;
    shadowTexCoord.y = shadowTexCoord.y/-2 + 0.5;

    shadowTexCoord.xy *= g_ShadowBias.xx;
    shadowTexCoord.xy += g_ShadowBias.yy;

    shadowTexCoord.x += face;
    shadowTexCoord.x *= rcp( 6 );

    shadowTexCoord.y += nShadowIndex;
    shadowTexCoord.y *= rcp( MAX_NUM_SHADOWCASTING_POINTS );

    
    
    shadowTexCoord.z -= lerp( 10.0, 1.0, saturate(5*fDistanceTerm) )*g_ShadowBias.z;

    return FilterShadow( g_PointShadowAtlas, shadowTexCoord.xyz );
}

float DoSpotShadow( int nShadowIndex, in float3 vPosition )
{
    float4 shadowTexCoord = mul( float4( vPosition, 1 ), g_mSpotShadowViewProj[ nShadowIndex ] );
    shadowTexCoord.xyz = shadowTexCoord.xyz / shadowTexCoord.w;

    shadowTexCoord.x = shadowTexCoord.x/2 + 0.5;
    shadowTexCoord.y = shadowTexCoord.y/-2 + 0.5;

    shadowTexCoord.x += nShadowIndex;
    shadowTexCoord.x *= rcp( MAX_NUM_SHADOWCASTING_SPOTS );

    shadowTexCoord.z -= g_ShadowBias.w;

    return FilterShadow( g_SpotShadowAtlas, shadowTexCoord.xyz );
}

void DoLighting(bool bDoShadow, in samplerBuffer PointLightBufferCenterAndRadius, in samplerBuffer PointLightBufferColor, in int nLightIndex, in float3 vPosition, in float3 vNorm, in float3 vViewDir, out float3 LightColorDiffuseResult, out float3 LightColorSpecularResult)
{
    float4 CenterAndRadius = texelFetch(PointLightBufferCenterAndRadius, nLightIndex);

    float3 vToLight = CenterAndRadius.xyz - vPosition;
    float3 vLightDir = normalize(vToLight);
    float fLightDistance = length(vToLight);

    LightColorDiffuseResult = float3(0,0,0);
    LightColorSpecularResult = float3(0,0,0);

    float fRad = CenterAndRadius.w;
    if( fLightDistance < fRad )
    {
        float x = fLightDistance / fRad;
        
        
        
        float fFalloff = -0.05 + 1.05/(1+20*x*x);
        LightColorDiffuseResult = texelFetch(PointLightBufferColor,nLightIndex).rgb * saturate(dot(vLightDir,vNorm)) * fFalloff;

        float3 vHalfAngle = normalize( vViewDir + vLightDir );
        LightColorSpecularResult = texelFetch(PointLightBufferColor, nLightIndex).rgb * pow( saturate(dot( vHalfAngle, vNorm )), 8 ) * fFalloff;

        if( bDoShadow )
        {
            float fShadowResult = DoShadow( nLightIndex, vPosition, vLightDir, x );
            LightColorDiffuseResult  *= fShadowResult;
            LightColorSpecularResult *= fShadowResult;
        }
    }
}

void DoSpotLighting(bool bDoShadow, in samplerBuffer SpotLightBufferCenterAndRadius, in samplerBuffer SpotLightBufferColor, in samplerBuffer SpotLightBufferSpotParams, in int nLightIndex, in float3 vPosition, in float3 vNorm, in float3 vViewDir, out float3 LightColorDiffuseResult, out float3 LightColorSpecularResult)
{
    float4 BoundingSphereCenterAndRadius = texelFetch(SpotLightBufferCenterAndRadius,nLightIndex);
    float4 SpotParams = texelFetch(SpotLightBufferSpotParams,nLightIndex);

    
    float3 SpotLightDir;
    SpotLightDir.xy = SpotParams.xy;
    SpotLightDir.z = sqrt(1 - SpotLightDir.x*SpotLightDir.x - SpotLightDir.y*SpotLightDir.y);

    
    SpotLightDir.z = (SpotParams.z > 0) ? SpotLightDir.z : -SpotLightDir.z;

    
    
    float3 LightPosition = BoundingSphereCenterAndRadius.xyz - BoundingSphereCenterAndRadius.w*SpotLightDir;

    float3 vToLight = LightPosition - vPosition;
    float3 vToLightNormalized = normalize(vToLight);
    float fLightDistance = length(vToLight);
    float fCosineOfCurrentConeAngle = dot(-vToLightNormalized, SpotLightDir);

    LightColorDiffuseResult = float3(0,0,0);
    LightColorSpecularResult = float3(0,0,0);

    float fRad = SpotParams.w;
    float fCosineOfConeAngle = (SpotParams.z > 0) ? SpotParams.z : -SpotParams.z;
    if( fLightDistance < fRad && fCosineOfCurrentConeAngle > fCosineOfConeAngle)
    {
        float fRadialAttenuation = (fCosineOfCurrentConeAngle - fCosineOfConeAngle) / (1.0 - fCosineOfConeAngle);
        fRadialAttenuation = fRadialAttenuation * fRadialAttenuation;

        float x = fLightDistance / fRad;
        
        
        
        float fFalloff = -0.05 + 1.05/(1+20*x*x);
        LightColorDiffuseResult = texelFetch(SpotLightBufferColor,nLightIndex).rgb * saturate(dot(vToLightNormalized,vNorm)) * fFalloff * fRadialAttenuation;

        float3 vHalfAngle = normalize( vViewDir + vToLightNormalized );
        LightColorSpecularResult = texelFetch(SpotLightBufferColor,nLightIndex).rgb * pow( saturate(dot( vHalfAngle, vNorm )), 8 ) * fFalloff * fRadialAttenuation;

        if( bDoShadow )
        {
            float fShadowResult = DoSpotShadow( nLightIndex, vPosition );
            LightColorDiffuseResult  *= fShadowResult;
            LightColorSpecularResult *= fShadowResult;
        }
    }
}

layout(binding = 7) buffer _VPLBufferData
{
    VPLData VPLBufferData[];
};

void DoVPLLighting(samplerBuffer VPLBufferCenterAndRadius,  in int nLightIndex, in float3 vPosition, in float3 vNorm, out float3 LightColorDiffuseResult)
{
    float4 CenterAndRadius = texelFetch(VPLBufferCenterAndRadius, nLightIndex);
    VPLData Data = VPLBufferData[nLightIndex];

    float3 vToLight = CenterAndRadius.xyz - vPosition;
    float3 vLightDir = normalize(vToLight);
    float fLightDistance = length(vToLight);

    LightColorDiffuseResult = float3(0,0,0);

    float fRad = CenterAndRadius.w;
    float fVPLNormalDotDir = max( 0, dot( Data.Direction.xyz, -vLightDir ) );

    if( fLightDistance < fRad && fVPLNormalDotDir > 0 )
    {
        float3 LightColor = Data.Color.rgb;

        float x = fLightDistance / fRad;
        float fFalloff = smoothstep( 1.0, 0.0, x );

        float fSourceLightNdotL = dot( Data.SourceLightDirection.xyz, vNorm );
        if ( fSourceLightNdotL < 0.0 )
        {
            fSourceLightNdotL = 1.0 + ( fSourceLightNdotL / g_fVPLRemoveBackFaceContrib );
        }
        else
        {
            fSourceLightNdotL = 1.0;
        }

        LightColorDiffuseResult = LightColor * saturate(dot(vLightDir,vNorm)) * fFalloff * fVPLNormalDotDir * fSourceLightNdotL;
    }
}






























#define FLT_MAX         3.402823466e+38F




#define NUM_THREADS_X TILE_RES
#define NUM_THREADS_Y TILE_RES
#define NUM_THREADS_PER_TILE (NUM_THREADS_X*NUM_THREADS_Y)







#if   ( TILED_CULLING_COMPUTE_SHADER_MODE == 0 )
#define FORWARD_PLUS 1
#define VPLS_ENABLED 0
#define BLENDED_PASS 0
#elif ( TILED_CULLING_COMPUTE_SHADER_MODE == 1 )
#define FORWARD_PLUS 1
#define VPLS_ENABLED 1
#define BLENDED_PASS 0
#elif ( TILED_CULLING_COMPUTE_SHADER_MODE == 2 )
#define FORWARD_PLUS 0
#define VPLS_ENABLED 0
#define BLENDED_PASS 0
#elif ( TILED_CULLING_COMPUTE_SHADER_MODE == 3 )
#define FORWARD_PLUS 0
#define VPLS_ENABLED 1
#define BLENDED_PASS 0
#elif ( TILED_CULLING_COMPUTE_SHADER_MODE == 4 )
#define FORWARD_PLUS 1
#define VPLS_ENABLED 0
#define BLENDED_PASS 1
#endif






layout(binding = 0) readonly buffer Buffer0
{
    float4 g_PointLightBufferCenterAndRadius[];
};

layout(binding = 1) readonly buffer Buffer1
{
    float4 g_SpotLightBufferCenterAndRadius[];
};



#if ( VPLS_ENABLED == 1 )

layout(binding = 2) readonly buffer Buffer2
{
    float4 g_VPLBufferCenterAndRadius[];
};
#endif

#if ( NUM_MSAA_SAMPLES <= 1 )   

layout(binding = 3) uniform sampler2D g_DepthTexture;
#elif ( FORWARD_PLUS == 1 )     

layout(binding = 3) uniform sampler2DMS g_DepthTexture;
#else                           

layout(binding = 3) uniform sampler2DMS g_DepthTexture;
#endif

#if ( BLENDED_PASS == 1 )
#if ( NUM_MSAA_SAMPLES <= 1 )   

layout(binding = 4) uniform sampler2D g_BlendedDepthTexture;
#else                           

layout(binding = 4) uniform sampler2DMS g_BlendedDepthTexture;
#endif
#endif





shared uint ldsZMax;
shared uint ldsZMin;


shared uint ldsLightIdxCounterA;
shared uint ldsLightIdxCounterB;
shared uint ldsLightIdx[2*MAX_NUM_LIGHTS_PER_TILE];


shared uint ldsSpotIdxCounterA;
shared uint ldsSpotIdxCounterB;
shared uint ldsSpotIdx[2*MAX_NUM_LIGHTS_PER_TILE];

#if ( VPLS_ENABLED == 1 )

shared uint ldsVPLIdxCounterA;
shared uint ldsVPLIdxCounterB;
shared uint ldsVPLIdx[2*MAX_NUM_VPLS_PER_TILE];
#endif

#if ( NUM_MSAA_SAMPLES > 1 ) && ( FORWARD_PLUS == 0 )  

shared uint ldsEdgePixelIdxCounter;
shared uint ldsEdgePixelIdx[NUM_THREADS_PER_TILE];
#endif







float4 CreatePlaneEquation( float4 b, float4 c )
{
    float4 n;

    
    n.xyz = normalize(cross( b.xyz, c.xyz ));

    
    n.w = 0;

    return n;
}



float GetSignedDistanceFromPlane( float4 p, float4 eqn )
{
    
    
    return dot( eqn.xyz, p.xyz );
}

#if ( NUM_MSAA_SAMPLES <= 1 )   
void CalculateMinMaxDepthInLds( uint3 globalIdx )
{
    float opaqueDepth = texelFetch(g_DepthTexture, int2(globalIdx.x,globalIdx.y), 0 ).x;
    float opaqueViewPosZ = ConvertProjDepthToView( opaqueDepth );
    uint opaqueZ = asuint( opaqueViewPosZ );

#if ( BLENDED_PASS == 1 )
    float blendedDepth = texelFetch(g_BlendedDepthTexture, int2(globalIdx.x,globalIdx.y), 0 ).x;
    float blendedViewPosZ = ConvertProjDepthToView( blendedDepth );
    uint blendedZ = asuint( blendedViewPosZ );

    
    if( blendedDepth != 0.f )
    {
        atomicMax( ldsZMax, opaqueZ );
        atomicMin( ldsZMin, blendedZ );
    }

#else
    
    if( opaqueDepth != 0.f )
    {
        atomicMax( ldsZMax, opaqueZ );
        atomicMin( ldsZMin, opaqueZ );
    }
#endif
}
#endif

#if ( NUM_MSAA_SAMPLES > 1 )    
bool CalculateMinMaxDepthInLdsMSAA( uint3 globalIdx, uint depthBufferNumSamples)
{
    float minZForThisPixel = FLT_MAX;
    float maxZForThisPixel = 0.f;

    float opaqueDepth0 = texelFetch(g_DepthTexture, int2(globalIdx.x,globalIdx.y), 0 ).x;
    float opaqueViewPosZ0 = ConvertProjDepthToView( opaqueDepth0 );

#if ( BLENDED_PASS == 1 )
    float blendedDepth0 = texelFetch(g_BlendedDepthTexture, int2(globalIdx.x,globalIdx.y), 0 ).x;
    float blendedViewPosZ0 = ConvertProjDepthToView( blendedDepth0 );

    
    if( blendedDepth0 != 0.f )
    {
        maxZForThisPixel = max( maxZForThisPixel, opaqueViewPosZ0 );
        minZForThisPixel = min( minZForThisPixel, blendedViewPosZ0 );
    }

#else
    
    if( opaqueDepth0 != 0.f )
    {
        maxZForThisPixel = max( maxZForThisPixel, opaqueViewPosZ0 );
        minZForThisPixel = min( minZForThisPixel, opaqueViewPosZ0 );
    }
#endif

    for( int sampleIdx=1; sampleIdx<int(depthBufferNumSamples); sampleIdx++ )
    {
        float opaqueDepth = texelFetch(g_DepthTexture, int2(globalIdx.x,globalIdx.y), sampleIdx ).x;
        float opaqueViewPosZ = ConvertProjDepthToView( opaqueDepth );

#if ( BLENDED_PASS == 1 )
        float blendedDepth =  texelFetch(g_BlendedDepthTexture, int2(globalIdx.x,globalIdx.y), sampleIdx ).x;
        float blendedViewPosZ = ConvertProjDepthToView( blendedDepth );

        
        if( blendedDepth != 0.f )
        {
            maxZForThisPixel = max( maxZForThisPixel, opaqueViewPosZ );
            minZForThisPixel = min( minZForThisPixel, blendedViewPosZ );
        }

#else
        
        if( opaqueDepth != 0.f )
        {
            maxZForThisPixel = max( maxZForThisPixel, opaqueViewPosZ );
            minZForThisPixel = min( minZForThisPixel, opaqueViewPosZ );
        }
#endif
    }

    uint zMaxForThisPixel = asuint( maxZForThisPixel );
    uint zMinForThisPixel = asuint( minZForThisPixel );
    atomicMax( ldsZMax, zMaxForThisPixel );
    atomicMax( ldsZMin, zMinForThisPixel );

    
    return ((maxZForThisPixel - minZForThisPixel) > 50.0f);
}
#endif

#if ( NUM_MSAA_SAMPLES <= 1 ) || ( FORWARD_PLUS == 1 )  
void
#else                                                   
bool
#endif
DoLightCulling( in uint3 globalIdx, in uint localIdxFlattened, in uint3 groupIdx, out float fHalfZ )
{
    if( localIdxFlattened == 0 )
    {
        ldsZMin = 0x7f7fffff;  
        ldsZMax = 0;
        ldsLightIdxCounterA = 0;
        ldsLightIdxCounterB = MAX_NUM_LIGHTS_PER_TILE;
        ldsSpotIdxCounterA = 0;
        ldsSpotIdxCounterB = MAX_NUM_LIGHTS_PER_TILE;
#if ( VPLS_ENABLED == 1 )
        ldsVPLIdxCounterA = 0;
        ldsVPLIdxCounterB = MAX_NUM_VPLS_PER_TILE;
#endif
#if ( NUM_MSAA_SAMPLES > 1 ) && ( FORWARD_PLUS == 0 )  
        ldsEdgePixelIdxCounter = 0;
#endif
    }

    float4 frustumEqn[4];
    {   
        uint pxm = TILE_RES*groupIdx.x;
        uint pym = TILE_RES*groupIdx.y;
        uint pxp = TILE_RES*(groupIdx.x+1);
        uint pyp = TILE_RES*(groupIdx.y+1);

        uint uWindowWidthEvenlyDivisibleByTileRes = TILE_RES*g_uNumTilesX;
        uint uWindowHeightEvenlyDivisibleByTileRes = TILE_RES*g_uNumTilesY;

        
        float4 frustum[4];
        frustum[0] = ConvertProjToView( float4( pxm/float(uWindowWidthEvenlyDivisibleByTileRes)*2.f-1.f, (uWindowHeightEvenlyDivisibleByTileRes-pym)/float(uWindowHeightEvenlyDivisibleByTileRes)*2.f-1.f,1.f,1.f) );
        frustum[1] = ConvertProjToView( float4( pxp/float(uWindowWidthEvenlyDivisibleByTileRes)*2.f-1.f, (uWindowHeightEvenlyDivisibleByTileRes-pym)/float(uWindowHeightEvenlyDivisibleByTileRes)*2.f-1.f,1.f,1.f) );
        frustum[2] = ConvertProjToView( float4( pxp/float(uWindowWidthEvenlyDivisibleByTileRes)*2.f-1.f, (uWindowHeightEvenlyDivisibleByTileRes-pyp)/float(uWindowHeightEvenlyDivisibleByTileRes)*2.f-1.f,1.f,1.f) );
        frustum[3] = ConvertProjToView( float4( pxm/float(uWindowWidthEvenlyDivisibleByTileRes)*2.f-1.f, (uWindowHeightEvenlyDivisibleByTileRes-pyp)/float(uWindowHeightEvenlyDivisibleByTileRes)*2.f-1.f,1.f,1.f) );

        
        
        
        
        for(uint i=0; i<4; i++)
            frustumEqn[i] = CreatePlaneEquation( frustum[i], frustum[(i+1)&3] );
    }

    GroupMemoryBarrierWithGroupSync();

    
    

#if ( NUM_MSAA_SAMPLES <= 1 )   
    CalculateMinMaxDepthInLds( globalIdx );
#else                           
#if ( FORWARD_PLUS == 1 )       


    int depthBufferNumSamples = textureSamples(g_DepthTexture);
    CalculateMinMaxDepthInLdsMSAA( globalIdx, depthBufferNumSamples );
#else                           
    uint depthBufferNumSamples = NUM_MSAA_SAMPLES;
    bool bIsEdge = CalculateMinMaxDepthInLdsMSAA( globalIdx, depthBufferNumSamples );
#endif
#endif

    GroupMemoryBarrierWithGroupSync();
    float maxZ = asfloat( ldsZMax );
    float minZ = asfloat( ldsZMin );
    fHalfZ = (minZ + maxZ) / 2.0f;

    
    for(uint i=localIdxFlattened; i<g_uNumLights; i+=NUM_THREADS_PER_TILE)
    {
        float4 center = g_PointLightBufferCenterAndRadius[i];
        float r = center.w;
        center.xyz = mul( float4(center.xyz, 1), g_mView ).xyz;

        
        if( ( GetSignedDistanceFromPlane( center, frustumEqn[0] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[1] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[2] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[3] ) < r ) )
        {
            if( -center.z + minZ < r && center.z - fHalfZ < r )
            {
                
                
                uint dstIdx = 0;
                dstIdx = atomicAdd( ldsLightIdxCounterA, 1 );
                ldsLightIdx[dstIdx] = i;
            }
            if( -center.z + fHalfZ < r && center.z - maxZ < r )
            {
                
                
                uint dstIdx = 0;
                dstIdx = atomicAdd( ldsLightIdxCounterB, 1 );
                ldsLightIdx[dstIdx] = i;
            }
        }
    }

    
    for(uint j=localIdxFlattened; j<g_uNumSpotLights; j+=NUM_THREADS_PER_TILE)
    {
        float4 center = g_SpotLightBufferCenterAndRadius[j];
        float r = center.w;
        center.xyz = mul( float4(center.xyz, 1), g_mView ).xyz;

        
        if( ( GetSignedDistanceFromPlane( center, frustumEqn[0] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[1] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[2] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[3] ) < r ) )
        {
            if( -center.z + minZ < r && center.z - fHalfZ < r )
            {
                
                
                uint dstIdx = 0;
                dstIdx = atomicAdd( ldsSpotIdxCounterA, 1 );
                ldsSpotIdx[dstIdx] = j;
            }
            if( -center.z + fHalfZ < r && center.z - maxZ < r )
            {
                
                
                uint dstIdx = 0;
                dstIdx = atomicAdd( ldsSpotIdxCounterB, 1 );
                ldsSpotIdx[dstIdx] = j;
            }
        }
    }



#if ( VPLS_ENABLED == 1 )
    
    uint numVPLs = min( g_uMaxVPLs, g_uNumVPLs );

    
    for(uint k=localIdxFlattened; k<numVPLs; k+=NUM_THREADS_PER_TILE)
    {
        float4 center = g_VPLBufferCenterAndRadius[k];
        float r = center.w;
        center.xyz = mul( float4(center.xyz, 1), g_mView ).xyz;

        
        if( ( GetSignedDistanceFromPlane( center, frustumEqn[0] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[1] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[2] ) < r ) &&
            ( GetSignedDistanceFromPlane( center, frustumEqn[3] ) < r ) )
        {
            if( -center.z + minZ < r && center.z - fHalfZ < r )
            {
                
                
                uint dstIdx = 0;
                dstIdx = atomicAdd( ldsVPLIdxCounterA, 1 );
                ldsVPLIdx[dstIdx] = k;
            }
            if( -center.z + fHalfZ < r && center.z - maxZ < r )
            {
                
                
                uint dstIdx = 0;
                dstIdx = atomicAdd( ldsVPLIdxCounterB, 1 );
                ldsVPLIdx[dstIdx] = k;
            }
        }
    }
#endif

    GroupMemoryBarrierWithGroupSync();

#if ( NUM_MSAA_SAMPLES <= 1 ) || ( FORWARD_PLUS == 1 )  
    return;
#else                                                   
    return bIsEdge;
#endif
}



layout (local_size_x = NUM_THREADS_X, local_size_x = NUM_THREADS_Y) in;

void main()
{
    uint3 globalIdx = SV_DispatchThreadID;
    uint3 localIdx = SV_GroupThreadID;
    uint3 groupIdx = SV_GroupID;

    uint localIdxFlattened = localIdx.x + localIdx.y*NUM_THREADS_X;

    
    
    
    float fHalfZ;
    #if ( NUM_MSAA_SAMPLES <= 1 )   
    DoLightCulling( globalIdx, localIdxFlattened, groupIdx, fHalfZ );
    #else                           
    bool bIsEdge = DoLightCulling( globalIdx, localIdxFlattened, groupIdx, fHalfZ );
    #endif

    
    #if ( NUM_MSAA_SAMPLES <= 1 )   
    float4 vNormAndSpecMask = g_GBuffer1Texture.Load( uint3(globalIdx.x,globalIdx.y,0) );
    #else                           
    float4 vNormAndSpecMask = g_GBuffer1Texture.Load( uint2(globalIdx.x,globalIdx.y), 0 );
    #endif
    float3 vNorm = vNormAndSpecMask.xyz;
    vNorm *= 2;
    vNorm -= float3(1,1,1);

    
    #if ( NUM_MSAA_SAMPLES <= 1 )   
    float fDepthBufferDepth = g_DepthTexture.Load( uint3(globalIdx.x,globalIdx.y,0) ).x;
    #else                           
    float fDepthBufferDepth = g_DepthTexture.Load( uint2(globalIdx.x,globalIdx.y), 0 ).x;
    #endif
    float4 vWorldSpacePosition = mul(float4((float)globalIdx.x+0.5, (float)globalIdx.y+0.5, fDepthBufferDepth, 1.0), g_mViewProjectionInvViewport);
    float3 vPositionWS = vWorldSpacePosition.xyz / vWorldSpacePosition.w;

    float3 vViewDir = normalize( g_vCameraPos - vPositionWS );

    float3 AccumDiffuse = float3(0,0,0);
    float3 AccumSpecular = float3(0,0,0);

    float fViewPosZ = ConvertProjDepthToView( fDepthBufferDepth );

    
    {
        uint uStartIdx = (fViewPosZ < fHalfZ) ? 0 : MAX_NUM_LIGHTS_PER_TILE;
        uint uEndIdx = (fViewPosZ < fHalfZ) ? ldsLightIdxCounterA : ldsLightIdxCounterB;

        for(uint i=uStartIdx; i<uEndIdx; i++)
        {
            uint nLightIndex = ldsLightIdx[i];

            float3 LightColorDiffuseResult;
            float3 LightColorSpecularResult;
            #if ( SHADOWS_ENABLED == 1 )
            DoLighting(true, g_PointLightBufferCenterAndRadius, g_PointLightBufferColor, nLightIndex, vPositionWS, vNorm, vViewDir, LightColorDiffuseResult, LightColorSpecularResult);
            #else
            DoLighting(false, g_PointLightBufferCenterAndRadius, g_PointLightBufferColor, nLightIndex, vPositionWS, vNorm, vViewDir, LightColorDiffuseResult, LightColorSpecularResult);
            #endif

            AccumDiffuse += LightColorDiffuseResult;
            AccumSpecular += LightColorSpecularResult;
        }
    }

    
    {
        uint uStartIdx = (fViewPosZ < fHalfZ) ? 0 : MAX_NUM_LIGHTS_PER_TILE;
        uint uEndIdx = (fViewPosZ < fHalfZ) ? ldsSpotIdxCounterA : ldsSpotIdxCounterB;

        for(uint i=uStartIdx; i<uEndIdx; i++)
        {
            uint nLightIndex = ldsSpotIdx[i];

            float3 LightColorDiffuseResult;
            float3 LightColorSpecularResult;
            #if ( SHADOWS_ENABLED == 1 )
            DoSpotLighting(true, g_SpotLightBufferCenterAndRadius, g_SpotLightBufferColor, g_SpotLightBufferSpotParams, nLightIndex, vPositionWS, vNorm, vViewDir, LightColorDiffuseResult, LightColorSpecularResult);
            #else
            DoSpotLighting(false, g_SpotLightBufferCenterAndRadius, g_SpotLightBufferColor, g_SpotLightBufferSpotParams, nLightIndex, vPositionWS, vNorm, vViewDir, LightColorDiffuseResult, LightColorSpecularResult);
            #endif

            AccumDiffuse += LightColorDiffuseResult;
            AccumSpecular += LightColorSpecularResult;
        }
    }

#if ( VPLS_ENABLED == 1 )
    
    {
        uint uStartIdx = (fViewPosZ < fHalfZ) ? 0 : MAX_NUM_VPLS_PER_TILE;
        uint uEndIdx = (fViewPosZ < fHalfZ) ? ldsVPLIdxCounterA : ldsVPLIdxCounterB;

        for(uint i=uStartIdx; i<uEndIdx; i++)
        {
            uint nLightIndex = ldsVPLIdx[i];

            float3 LightColorDiffuseResult;
            DoVPLLighting(g_VPLBufferCenterAndRadius, g_VPLBufferData, nLightIndex, vPositionWS, vNorm, LightColorDiffuseResult);

            AccumDiffuse += LightColorDiffuseResult;
        }
    }
#endif

    
    AccumDiffuse *= 2;
    AccumSpecular *= 8;

    
    
    #if ( NUM_MSAA_SAMPLES <= 1 )   
    #if ( NUM_GBUFFER_RTS >= 3 )
    float4 Dummy0 = g_GBuffer2Texture.Load( uint3(globalIdx.x,globalIdx.y,0) );
    AccumDiffuse *= Dummy0.xyz;
    AccumSpecular *= Dummy0.xyz;
    #endif
    #if ( NUM_GBUFFER_RTS >= 4 )
    float4 Dummy1 = g_GBuffer3Texture.Load( uint3(globalIdx.x,globalIdx.y,0) );
    AccumDiffuse *= Dummy1.xyz;
    AccumSpecular *= Dummy1.xyz;
    #endif
    #if ( NUM_GBUFFER_RTS >= 5 )
    float4 Dummy2 = g_GBuffer4Texture.Load( uint3(globalIdx.x,globalIdx.y,0) );
    AccumDiffuse *= Dummy2.xyz;
    AccumSpecular *= Dummy2.xyz;
    #endif

    #else                           
    #if ( NUM_GBUFFER_RTS >= 3 )
    float4 Dummy0 = g_GBuffer2Texture.Load( uint2(globalIdx.x,globalIdx.y), 0 );
    AccumDiffuse *= Dummy0.xyz;
    AccumSpecular *= Dummy0.xyz;
    #endif
    #if ( NUM_GBUFFER_RTS >= 4 )
    float4 Dummy1 = g_GBuffer3Texture.Load( uint2(globalIdx.x,globalIdx.y), 0 );
    AccumDiffuse *= Dummy1.xyz;
    AccumSpecular *= Dummy1.xyz;
    #endif
    #if ( NUM_GBUFFER_RTS >= 5 )
    float4 Dummy2 = g_GBuffer4Texture.Load( uint2(globalIdx.x,globalIdx.y), 0 );
    AccumDiffuse *= Dummy2.xyz;
    AccumSpecular *= Dummy2.xyz;
    #endif
    #endif

    
    float fAmbientBlend = 0.5f * vNorm.y + 0.5;
    float3 Ambient = g_AmbientColorUp.rgb * fAmbientBlend + g_AmbientColorDown.rgb * (1-fAmbientBlend);
    float3 DiffuseAndAmbient = AccumDiffuse + Ambient;

    
    #if ( NUM_MSAA_SAMPLES <= 1 )   
    float3 DiffuseTex = g_GBuffer0Texture.Load( uint3(globalIdx.x,globalIdx.y,0) ).rgb;
    #else                           
    float3 DiffuseTex = g_GBuffer0Texture.Load( uint2(globalIdx.x,globalIdx.y), 0 ).rgb;
    #endif
    float fSpecMask = vNormAndSpecMask.a;

    float3 Result = DiffuseTex*(DiffuseAndAmbient + AccumSpecular*fSpecMask);



#if ( LIGHTS_PER_TILE_MODE > 0 )
    uint uStartIdx = (fViewPosZ < fHalfZ) ? 0 : MAX_NUM_LIGHTS_PER_TILE;
    uint uEndIdx = (fViewPosZ < fHalfZ) ? ldsLightIdxCounterA : ldsLightIdxCounterB;
    uint nNumLightsInThisTile = uEndIdx-uStartIdx;
    uEndIdx = (fViewPosZ < fHalfZ) ? ldsSpotIdxCounterA : ldsSpotIdxCounterB;
    nNumLightsInThisTile += uEndIdx-uStartIdx;
    uint uMaxNumLightsPerTile = 2*g_uMaxNumLightsPerTile;  
#if ( VPLS_ENABLED == 1 )
    uStartIdx = (fViewPosZ < fHalfZ) ? 0 : MAX_NUM_VPLS_PER_TILE;
    uEndIdx = (fViewPosZ < fHalfZ) ? ldsVPLIdxCounterA : ldsVPLIdxCounterB;
    nNumLightsInThisTile += uEndIdx-uStartIdx;
    uMaxNumLightsPerTile += g_uMaxNumVPLsPerTile;
#endif
#if ( LIGHTS_PER_TILE_MODE == 1 )
    Result = ConvertNumberOfLightsToGrayscale(nNumLightsInThisTile, uMaxNumLightsPerTile).rgb;
#elif ( LIGHTS_PER_TILE_MODE == 2 )
    Result = ConvertNumberOfLightsToRadarColor(nNumLightsInThisTile, uMaxNumLightsPerTile).rgb;
#endif
#endif

#if ( NUM_MSAA_SAMPLES <= 1 )   
    g_OffScreenBufferOut[globalIdx.xy] = float4(Result,1);
#else                           

    uint2 uavMsaaBufferCoord = globalIdx.xy * uint2(2,2);
    g_OffScreenBufferOut[uavMsaaBufferCoord] = float4(Result,1);

    for( uint sampleIdx=1; sampleIdx<NUM_MSAA_SAMPLES; sampleIdx++ )
    {
        float3 vNormSample = g_GBuffer1Texture.Load( uint2(globalIdx.x,globalIdx.y), sampleIdx ).xyz;
        vNormSample *= 2;
        vNormSample -= float3(1,1,1);
        bIsEdge = bIsEdge || dot(vNormSample, vNorm) < 0.984807753f;
    }

    if( bIsEdge )
    {
        
        
        uint dstIdx = 0;
        InterlockedAdd( ldsEdgePixelIdxCounter, 1, dstIdx );
        ldsEdgePixelIdx[dstIdx] = (globalIdx.y << 16) | globalIdx.x;
    }
    else
    {
        g_OffScreenBufferOut[uavMsaaBufferCoord + uint2(1, 0)] = float4(Result,1);
        g_OffScreenBufferOut[uavMsaaBufferCoord + uint2(0, 1)] = float4(Result,1);
        g_OffScreenBufferOut[uavMsaaBufferCoord + uint2(1, 1)] = float4(Result,1);
    }

    GroupMemoryBarrierWithGroupSync();

    
    {
        uint uNumSamplesToLight = (NUM_MSAA_SAMPLES-1) * ldsEdgePixelIdxCounter;

        for(uint i=localIdxFlattened; i<uNumSamplesToLight; i+=NUM_THREADS_PER_TILE)
        {
            uint edgePixelListIdx = i / (NUM_MSAA_SAMPLES-1);
            uint sampleIdx = (i % (NUM_MSAA_SAMPLES-1)) + 1;

            uint edgePixelIdxPacked = ldsEdgePixelIdx[edgePixelListIdx];
            uint2 globalIdxForThisEdgePixel = uint2(edgePixelIdxPacked & 0x0000FFFF, edgePixelIdxPacked >> 16);

            uint2 litSampleCoord = globalIdxForThisEdgePixel * uint2(2, 2);
            litSampleCoord.x += sampleIdx % 2;
            litSampleCoord.y += sampleIdx > 1;
            g_OffScreenBufferOut[litSampleCoord] = float4(DoLightingForMSAA(globalIdxForThisEdgePixel, sampleIdx, fHalfZ),1);
        }
    }
#endif
}
