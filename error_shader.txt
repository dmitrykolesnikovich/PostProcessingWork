#version 450





#ifndef GL_ES


#endif

#define float2 vec2
#define bool4 bvec4

#define float3 vec3
#define float4 vec4
#define bool2 bvec2
#define bool3 bvec3
#define float2x2 mat2
#define float3x3 mat3
#define float4x4 mat4
#define matrix   mat4
#define float4x3 mat4x3

#define half2 vec2
#define half3 vec3
#define half4 vec4

#define uint2 uvec2
#define uint3 uvec3
#define uint4 uvec4

#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

#define lerp(x,y,v) mix(x,y,v)
#define rcp(x) 1.0/x
#define saturate(x) clamp(x, 0.0, 1.0)
#define frac(x) fract(x)
#define rsqrt(x) inversesqrt(x)
#define InterlockedOr(x, y) atomicOr(x, y)
#define firstbithigh(x) findMSB(x)
#define firstbitlow(x)  findLSB(x)
#define atan2(y,x)  atan(y,x)
#define reversebits(x) bitfieldReverse(x)
#define countbits(x)   bitCount(x)
#define asuint(x) floatBitsToUint(x)
#define ddx(x)    dFdx(x)
#define ddy(x)    dFdy(x)



#define isfinite(x) !(isnan(x) || isinf(x))

#ifndef GroupMemoryBarrierWithGroupSync
#define GroupMemoryBarrierWithGroupSync barrier
#endif
#define groupshared shared

#define GroupMemoryBarrier memoryBarrier

vec4 mul(in vec4 v, in mat4 m )
{
	return m * v;
}

vec3 mul(in vec3 v, in mat3 m )
{
	return m * v;
}

vec4 mul(in mat4 m , in vec4 v)
{
	return m * v;
}

vec3 mul(in mat3 m , in vec3 v)
{
	return m * v;
}

vec2 mul(in mat2 m , in vec2 v)
{
	return m * v;
}

void sincos(float angle, out float _sin, out float _cos)
{
    _sin = sin(angle);
    _cos = cos(angle);
}

void sincos(float2 angle, out float2 _sin, out float2 _cos)
{
    _sin = sin(angle);
    _cos = cos(angle);
}

float asfloat(uint i)
{
    return uintBitsToFloat(i);
}

float asfloat(int i)
{
    return intBitsToFloat(i);
}

float f16tof32( in uint value)
{
    return unpackHalf2x16(value).x;
}

float2 f16tof32( in uint2 value)
{
    return float2(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x);
}

float3 f16tof32( in uint3 value)
{
    return float3(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x, unpackHalf2x16(value.z).x);
}

float4 f16tof32( in uint4 value)
{
    return float4(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x, unpackHalf2x16(value.z).x, unpackHalf2x16(value.w).x);
}

uint f32tof16(in float value)
{
    return packHalf2x16(vec2(value, 0));
}

uint2 f32tof16(in vec2 value)
{
    return uint2(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)));
}

uint3 f32tof16(in float3 value)
{
    return uint3(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)), packHalf2x16(vec2(value.z, 0)));
}


uint4 f32tof16(in float4 value)
{
    return uint4(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)), packHalf2x16(vec2(value.z, 0)), packHalf2x16(vec2(value.w, 0)));
}

#define SV_ThreadGroupSize gl_WorkGroupSize
#define SV_NumThreadGroup  gl_NumWorkGroups
#define SV_GroupID         gl_WorkGroupID
#define SV_GroupThreadID   gl_LocalInvocationID
#define SV_DispatchThreadID gl_GlobalInvocationID
#define SV_GroupIndex      gl_LocalInvocationIndex


#if GL_ES

#if __VERSION__ < 300
    #define texture(x, y) texture2D(x, y)
#endif

#if __VERSION__  >= 300
	#define ENABLE_VERTEX_ID 1
	#define ENABLE_IN_OUT_FEATURE 1
	#define LAYOUT_LOC(x)  layout(location = x)
#else
	#define LAYOUT_LOC(x)
#endif

#if __VERSION__ == 300
    vec4 textureGather(sampler2D tex, vec2 uv, int comp)
    {
        vec4 c0 = textureOffset(tex, uv, ivec2(0,1));
        vec4 c1 = textureOffset(tex, uv, ivec2(1,1));
        vec4 c2 = textureOffset(tex, uv, ivec2(1,0));
        vec4 c3 = textureOffset(tex, uv, ivec2(0,0));

        return vec4(c0[comp], c1[comp], c2[comp],c3[comp]);
    }
#elif __VERSION__ < 300

    vec4 textureGather(sampler2D tex, vec2 uv, int comp)
    {
        vec4 c3 = texture2D(tex, uv);
        return vec4(c3[comp], c3[comp], c3[comp],c3[comp]);
    }
#endif

#else  


 #define ENABLE_VERTEX_ID 1

 #if __VERSION__ >= 130
 #define ENABLE_IN_OUT_FEATURE 1
 #endif

 #if __VERSION__ >= 410
    #define LAYOUT_LOC(x)  layout(location = x)
 #else
    #define LAYOUT_LOC(x)
 #endif

 #if __VERSION__ < 400
     vec4 textureGather(sampler2D tex, vec2 uv, int comp)
     {
         vec4 c0 = textureOffset(tex, uv, ivec2(0,1));
         vec4 c1 = textureOffset(tex, uv, ivec2(1,1));
         vec4 c2 = textureOffset(tex, uv, ivec2(1,0));
         vec4 c3 = textureOffset(tex, uv, ivec2(0,0));

         return vec4(c0[comp], c1[comp], c2[comp],c3[comp]);
     }
 #endif

#endif

#ifndef ENABLE_VERTEX_ID
#define ENABLE_VERTEX_ID 0
#endif

#ifndef ENABLE_IN_OUT_FEATURE
#define ENABLE_IN_OUT_FEATURE 0
#endif

#ifndef ENABLE_POS_TRANSFORM
#define ENABLE_POS_TRANSFORM 0
#endif




#if GL_ES
precision highp float;
#endif

#if ENABLE_IN_OUT_FEATURE
    in vec4 m_f4UVAndScreenPos;
    LAYOUT_LOC(0) out vec4 Out_f4Color;
#else
    varying vec4 m_f4UVAndScreenPos;
   #define Out_f4Color gl_FragColor
#endif


uniform sampler2D iChannel0;
uniform sampler2D iPaper;


uniform vec4 g_Uniforms;
#define iResolution g_Uniforms.xy
#define g_RectBorder      g_Uniforms.z
#define g_Alpha           g_Uniforms.w   

#define EPSILON 0.000011
#define SAMPLES  5.0

float DistToRect(vec2 uv)
{
    float prop = iResolution.y / iResolution.x;

    float Xmin = g_RectBorder;
    float Xmax = 1.0 - g_RectBorder;
    float Ymin = g_RectBorder;
    float Ymax = prop - Ymin;

    float X = clamp(uv.x, Xmin, Xmax);
    float Y = clamp(uv.y, Ymin, Ymax);



    return distance(uv, vec2(X,Y));
}


float hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }

float ConstractLinear(float color, float middleGray, float c)
{
    
    return color + (color - middleGray) * c;
}

float ConstractLog(float color, float c)
{
    const float F = 1.0;
    return c * log(color * F + 1.0) / F;
}

float ConstractPower(float color, float c, float gamma)
{
    float diff = color - 100.0 / 256.0;
    return c * pow(abs(diff), gamma) * sign(diff) + 100.0 / 256.0;
}

void mainImage( out vec4 fragColor ){
    
    vec2 uv = m_f4UVAndScreenPos.xy;

    
    
    
    float decay = 0.97;
    
    float density = 0.02;
    
    float weight = 1.0f/SAMPLES;

    float iGlobalTime = 10.0;
    
    vec3 l = vec3(0);

    
    
    
    
    
    
    
    vec2 tuv = uv - 0.5;

    
    
    
    vec2 dTuv = tuv*density * weight;

    
    
    vec4 col = texture(iChannel0, uv.xy) * weight;

    
    
    uv += dTuv*(hash(uv.xy + fract(iGlobalTime))*2. - 1.);

    float totalWeight = 1.0 / SAMPLES;
    
    
    
    for(float i=0.; i < SAMPLES; i++){

        uv -= dTuv;
        col += texture(iChannel0, uv) * weight;
        totalWeight += weight;

        weight *= decay;
    }

    
    
    
    col *= (1. - dot(tuv, tuv)*.75);
    col /= totalWeight;

    
    fragColor = smoothstep(0., 1., col);
    fragColor  = col;
}

#define USE_PAPER 1

float overlaySingle(float s, float d)
{
    int di = int(d * 255.0);
    int si = int(s * 255.0);

    int t;
    int dor;
    if ( di < 128 )
    {
        t = di * si + 0x80;
        dor = 2 * (((t >> 8) + t) >> 8);
    }
    else
    {
        t = (255-di) * (255-si) + 0x80;
        dor = 2 * (255 - ( ((t >> 8) + t) >> 8 ));
    }

    return float(dor) / 255.0;
}

vec3 overlay(vec4 src, vec4 dst)
{
    vec3 result;
    result.r = overlaySingle(src.r, dst.r);
    result.g = overlaySingle(src.g, dst.g);
    result.b = overlaySingle(src.b, dst.b);

    return mix(dst.rgb, result.rgb, g_Alpha);
}

void main(void)
{
    if(USE_PAPER != 0)
    {
        vec4 src0 = texture(iChannel0, m_f4UVAndScreenPos.xy).rgb;

        vec4 src1 = texture(iPaper, m_f4UVAndScreenPos.xy).rgb;

        Out_f4Color.rgb = overlay(src0, src1);
        Out_f4Color.a = 1;
    }
    else
    {
        vec2 p = gl_FragCoord.xy / iResolution.x;
        float dist = DistToRect(p);

        
        float fade = smoothstep(0.,1., dist / g_RectBorder);
        

        

        vec4 backgroundColor;
        mainImage(backgroundColor);

        
        const vec3 ToGray = vec3(0.299, 0.587, 0.114);

        float grayCol = dot(backgroundColor.rgb, ToGray);
        

        grayCol = ConstractPower(grayCol, 1.0, 1);

        
        Out_f4Color = vec4(mix(vec3(grayCol), vec3(0.0), fade), 1.0);
    }


}
