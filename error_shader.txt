#version 450
#define USE_ALPHA_TEST 0
#define NUM_GBUFFER_RTS 2










#ifndef GL_ES


#endif

#define float2 vec2
#define bool4 bvec4

#define float3 vec3
#define float4 vec4
#define bool2 bvec2
#define bool3 bvec3
#define float2x2 mat2
#define float3x3 mat3
#define float4x4 mat4
#define matrix   mat4
#define float4x3 mat4x3

#define half2 vec2
#define half3 vec3
#define half4 vec4

#define uint2 uvec2
#define uint3 uvec3
#define uint4 uvec4

#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

#define lerp(x,y,v) mix(x,y,v)
#define rcp(x) 1.0/x
#define saturate(x) clamp(x, 0.0, 1.0)
#define frac(x) fract(x)
#define rsqrt(x) inversesqrt(x)
#define InterlockedOr(x, y) atomicOr(x, y)
#define firstbithigh(x) findMSB(x)
#define firstbitlow(x)  findLSB(x)
#define atan2(y,x)  atan(y,x)
#define reversebits(x) bitfieldReverse(x)
#define countbits(x)   bitCount(x)
#define asuint(x) floatBitsToUint(x)
#define ddx(x)    dFdx(x)
#define ddy(x)    dFdy(x)



#define isfinite(x) !(isnan(x) || isinf(x))

#ifndef GroupMemoryBarrierWithGroupSync
#define GroupMemoryBarrierWithGroupSync barrier
#endif
#define groupshared shared

#define GroupMemoryBarrier memoryBarrier

vec4 mul(in vec4 v, in mat4 m )
{
	return m * v;
}

vec3 mul(in vec3 v, in mat3 m )
{
	return m * v;
}

vec4 mul(in mat4 m , in vec4 v)
{
	return m * v;
}

vec3 mul(in mat3 m , in vec3 v)
{
	return m * v;
}

vec2 mul(in mat2 m , in vec2 v)
{
	return m * v;
}

void sincos(float angle, out float _sin, out float _cos)
{
    _sin = sin(angle);
    _cos = cos(angle);
}

void sincos(float2 angle, out float2 _sin, out float2 _cos)
{
    _sin = sin(angle);
    _cos = cos(angle);
}

float asfloat(uint i)
{
    return uintBitsToFloat(i);
}

float asfloat(int i)
{
    return intBitsToFloat(i);
}

float f16tof32( in uint value)
{
    return unpackHalf2x16(value).x;
}

float2 f16tof32( in uint2 value)
{
    return float2(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x);
}

float3 f16tof32( in uint3 value)
{
    return float3(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x, unpackHalf2x16(value.z).x);
}

float4 f16tof32( in uint4 value)
{
    return float4(unpackHalf2x16(value.x).x, unpackHalf2x16(value.y).x, unpackHalf2x16(value.z).x, unpackHalf2x16(value.w).x);
}

uint f32tof16(in float value)
{
    return packHalf2x16(vec2(value, 0));
}

uint2 f32tof16(in vec2 value)
{
    return uint2(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)));
}

uint3 f32tof16(in float3 value)
{
    return uint3(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)), packHalf2x16(vec2(value.z, 0)));
}


uint4 f32tof16(in float4 value)
{
    return uint4(packHalf2x16(vec2(value.x, 0)), packHalf2x16(vec2(value.y, 0)), packHalf2x16(vec2(value.z, 0)), packHalf2x16(vec2(value.w, 0)));
}

#define SV_ThreadGroupSize gl_WorkGroupSize
#define SV_NumThreadGroup  gl_NumWorkGroups
#define SV_GroupID         gl_WorkGroupID
#define SV_GroupThreadID   gl_LocalInvocationID
#define SV_DispatchThreadID gl_GlobalInvocationID
#define SV_GroupIndex      gl_LocalInvocationIndex





const float4 kRadarColors[14] = float4[14]
(
    float4(0,0.9255,0.9255,1),   
    float4(0,0.62745,0.9647,1),  
    float4(0,0,0.9647,1),        
    float4(0,1,0,1),             
    float4(0,0.7843,0,1),        
    float4(0,0.5647,0,1),        
    float4(1,1,0,1),             
    float4(0.90588,0.75294,0,1), 
    float4(1,0.5647,0,1),        
    float4(1,0,0,1),             
    float4(0.8392,0,0,1),        
    float4(0.75294,0,0,1),       
    float4(1,0,1,1),             
    float4(0.6,0.3333,0.7882,1)  
);





#define TILE_RES 16
#define MAX_NUM_LIGHTS_PER_TILE 272
#define MAX_NUM_VPLS_PER_TILE 1024





#define MAX_NUM_SHADOWCASTING_POINTS     12
#define MAX_NUM_SHADOWCASTING_SPOTS      12






uniform mat4 g_mWorld;
uniform mat4 g_mViewProjection;
uniform float2 g_CameraRange;   

layout(binding = 0) uniform cbPerFrame 
{
    matrix              g_mView                      ;
    matrix              g_mProjection                ;
    matrix              g_mProjectionInv             ;
    matrix              g_mViewProjectionInvViewport ;
    float4              g_AmbientColorUp             ;
    float4              g_AmbientColorDown           ;
    float3              g_vCameraPos                 ;
    float               g_fAlphaTest                 ;
    uint                g_uNumLights                 ;
    uint                g_uNumSpotLights             ;
    uint                g_uWindowWidth               ;
    uint                g_uWindowHeight              ;
    uint                g_uMaxNumLightsPerTile       ;
    uint                g_uMaxNumElementsPerTile     ;
    uint                g_uNumTilesX                 ;
    uint                g_uNumTilesY                 ;
    uint                g_uMaxVPLs                   ;
    uint                g_uMaxNumVPLsPerTile         ;
    uint                g_uMaxNumVPLElementsPerTile  ;
    float               g_fVPLSpotStrength           ;
    float               g_fVPLSpotRadius             ;
    float               g_fVPLPointStrength          ;
    float               g_fVPLPointRadius            ;
    float               g_fVPLRemoveBackFaceContrib  ;
    float               g_fVPLColorThreshold         ;
    float               g_fVPLBrightnessThreshold    ;
    float               g_fPerFramePad1              ;
    float               g_fPerFramePad2              ;
};

layout(binding = 1) uniform cbShadowConstants 
{
    matrix              g_mPointShadowViewProj[ MAX_NUM_SHADOWCASTING_POINTS ][ 6 ];
    matrix              g_mSpotShadowViewProj[ MAX_NUM_SHADOWCASTING_SPOTS ];
    float4              g_ShadowBias;  
};

layout(binding = 2) uniform cbVPLConstants 
{
    uint                g_uNumVPLs;
    uint                g_uVPLPad[ 3 ];
};

struct VPLData
{
    float4 Direction;
    float4 Color;
    float4 SourceLightDirection;
};













float4 ConvertProjToView( float4 p )
{
    p = mul( p, g_mProjectionInv );
    p /= p.w;
    return p;
}


float ConvertProjDepthToView( float z )
{
    float mZFar =g_CameraRange.y;
    float mZNear = g_CameraRange.x;
    float fCamSpaceZ = mZFar*mZNear/(mZFar-z*(mZFar-mZNear));

    return fCamSpaceZ;
}

uint GetTileIndex(float2 ScreenPos)
{
    float fTileRes = float(TILE_RES);
    uint nTileIdx = uint(floor(ScreenPos.x/fTileRes)+floor(ScreenPos.y/fTileRes)*g_uNumTilesX);
    return nTileIdx;
}



void GetLightListInfo(usamplerBuffer PerTileLightIndexBuffer, in uint uMaxNumLightsPerTile, in uint uMaxNumElementsPerTile, in float4 SVPosition, out uint uFirstLightIndex, out uint uNumLights)
{
    uint nTileIndex = GetTileIndex(SVPosition.xy);
    int nStartIndex = int(uMaxNumElementsPerTile*nTileIndex);

    
    uint uHalfZBitsHigh = texelFetch(PerTileLightIndexBuffer, nStartIndex).x;
    uint uHalfZBitsLow = texelFetch(PerTileLightIndexBuffer, nStartIndex+1).x;
    uint uHalfZBits = (uHalfZBitsHigh << 16) | uHalfZBitsLow;
    float fHalfZ = asfloat(uHalfZBits);

    float fViewPosZ = ConvertProjDepthToView( SVPosition.z );

    uFirstLightIndex = (fViewPosZ < fHalfZ) ? (nStartIndex + 4) : (nStartIndex + 4 + uMaxNumLightsPerTile);
    uNumLights = (fViewPosZ < fHalfZ) ? texelFetch(PerTileLightIndexBuffer, nStartIndex+2).x : texelFetch(PerTileLightIndexBuffer, nStartIndex+3).x;
}

float4 ConvertNumberOfLightsToGrayscale(uint nNumLightsInThisTile, uint uMaxNumLightsPerTile)
{
    float fPercentOfMax = float(nNumLightsInThisTile) / float(uMaxNumLightsPerTile);
    return float4(fPercentOfMax, fPercentOfMax, fPercentOfMax, 1.0f);
}

float4 ConvertNumberOfLightsToRadarColor(uint nNumLightsInThisTile, uint uMaxNumLightsPerTile)
{
    
    if( nNumLightsInThisTile == 0 ) return float4(0,0,0,1);
    
    else if( nNumLightsInThisTile == uMaxNumLightsPerTile ) return float4(0.847,0.745,0.921,1);
    
    else if ( nNumLightsInThisTile > uMaxNumLightsPerTile ) return float4(1,1,1,1);
    
    else
    {
        

        
        
        float fLogBase = exp2(0.07142857f*log2(float(uMaxNumLightsPerTile)));

        
        
        int nColorIndex = int(floor(log2(float(nNumLightsInThisTile)) / log2(fLogBase)));
        return kRadarColors[nColorIndex];
    }
}


in VS_OUTPUT_SCENE
{

    float3 Normal       ;      
    float2 TextureUV    ;   
    float3 Tangent      ;   
}Input;

layout(location = 0) out float4 RT0 ;  
layout(location = 1) out float4 RT1 ;  
#if ( NUM_GBUFFER_RTS >= 3 )
layout(location = 2) out float4 RT2 ;  
#endif
#if ( NUM_GBUFFER_RTS >= 4 )
layout(location = 3) out float4 RT3 ;  
#endif
#if ( NUM_GBUFFER_RTS >= 5 )
layout(location = 4) out float4 RT4 ;  
#endif

layout(binding = 0) uniform sampler2D g_TxDiffuse;
layout(binding = 1) uniform sampler2D g_TxNormal;





void main()
{
    
    float4 DiffuseTex = texture( g_TxDiffuse, Input.TextureUV );

#if ( USE_ALPHA_TEST == 1 )
    float fAlpha = DiffuseTex.a;
    if( fAlpha < g_fAlphaTest ) discard;
#endif

    
    float3 vNorm = texture( g_TxNormal, Input.TextureUV ).xyz;
    vNorm *= 2;
    vNorm -= float3(1,1,1);

    
    float3 vBinorm = normalize( cross( Input.Normal, Input.Tangent ) );
    float3x3 BTNMatrix = float3x3( vBinorm, Input.Tangent, Input.Normal );
    vNorm = normalize(mul( vNorm, BTNMatrix ));

#if ( USE_ALPHA_TEST == 1 )
    RT0 = DiffuseTex;
    RT1 = float4(0.5*vNorm + 0.5, 0);
#else
    RT0 = float4(DiffuseTex.rgb, 1);
    RT1 = float4(0.5*vNorm + 0.5, DiffuseTex.a);
#endif

    
    
#if ( NUM_GBUFFER_RTS >= 3 )
    RT2 = float4(1,1,1,1);
#endif
#if ( NUM_GBUFFER_RTS >= 4 )
    RT3 = float4(1,1,1,1);
#endif
#if ( NUM_GBUFFER_RTS >= 5 )
    RT4 = float4(1,1,1,1);
#endif

    return Output;
}
